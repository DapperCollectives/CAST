package shared

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum/rlp"
)

///////////////////
// Voucher Structs
///////////////////

type ProposalKey struct {
	Address     string `json:"address"`
	KeyId       uint   `json:"keyId"`
	SequenceNum uint   `json:"sequenceNum"`
}
type PayloadSig struct {
	Address string `json:"address"`
	KeyId   uint   `json:"keyId"`
	Sig     string `json:"sig"`
}
type Voucher struct {
	Cadence      string              `json:"cadence"`
	RefBlock     string              `json:"refBlock"`
	ComputeLimit uint                `json:"computeLimit"`
	Arguments    []map[string]string `json:"arguments"`
	Payer        string              `json:"payer"`
	Authorizers  []string            `json:"authorizers"`
	ProposalKey  ProposalKey         `json:"proposalKey"`
	PayloadSigs  []PayloadSig        `json:"payloadSigs"`
	EnvelopeSigs []PayloadSig        `json:"envelopeSigs"`
}

func rightPaddedBuffer(s string, numBytes uint) string {
	format := "%-" + fmt.Sprintf("%d", numBytes*2) + "s"
	_rightPaddedStr := fmt.Sprintf(format, s)
	rightPaddedStr := strings.Replace(_rightPaddedStr, " ", "0", int(numBytes*2))
	return rightPaddedStr
}
func leftPaddedBuffer(s string, numBytes uint) []byte {
	format := "%0" + fmt.Sprintf("%d", numBytes*2) + "s"
	leftPaddedStr := fmt.Sprintf(format, s)
	data, _ := hex.DecodeString(leftPaddedStr)
	return data
}
func blockBuffer(s string) []byte {
	return leftPaddedBuffer(s, 32)
}
func addressBuffer(s string) []byte {
	return leftPaddedBuffer(s, 8)
}
func sansPrefix(addr string) string {
	return strings.TrimPrefix(addr, "0x")
}
func rlpEncode(p interface{}) string {
	b := new(bytes.Buffer)
	_ = rlp.Encode(b, p)
	return hex.EncodeToString(b.Bytes())
}

func EncodeMessageFromVoucher(v *Voucher) string {
	var toEncode []interface{}

	// CADENCE
	toEncode = append(toEncode, v.Cadence)

	// ARGUMENTS
	// Stringify tx args
	args := make([]string, len(v.Arguments))
	for i, arg := range v.Arguments {
		jsonStrArg, _ := json.Marshal(arg)
		args[i] = string(jsonStrArg)
	}
	toEncode = append(toEncode, args)

	// REF BLOCK
	toEncode = append(toEncode, blockBuffer(v.RefBlock))

	// COMPUTE LIMIT
	toEncode = append(toEncode, v.ComputeLimit)

	// PROPOSAL KEY ADDRESS
	proposalAddrData := addressBuffer(sansPrefix(v.ProposalKey.Address))
	toEncode = append(toEncode, proposalAddrData)

	// PROPOSAL KEY ID
	toEncode = append(toEncode, v.ProposalKey.KeyId)

	// PROPOSAL KEY SEQ NUM
	toEncode = append(toEncode, v.ProposalKey.SequenceNum)

	// PAYER
	payerData := leftPaddedBuffer(sansPrefix(v.Payer), 8)
	toEncode = append(toEncode, payerData) // 8 bytes left padded w/ 0s

	// AUTHORIZERS
	authorizers := make([][]byte, len(v.Authorizers))
	// pad authorizer addresses
	for i, addr := range v.Authorizers {
		authorizers[i] = addressBuffer(sansPrefix(addr))
	}
	toEncode = append(toEncode, authorizers)

	// We only want to generate the message signed by the user.
	//
	// If wallet is custodial, then the user will sign the tx payload
	// and the custodian will sign the envelope. In this case, only generate
	// the encoded tx payload, i.e. the message signed by the user.
	//
	// If wallet is non-custodial, the user only needs to sign the envelope, so
	// payloadSigs will be empty.  In this case, generate the encoded tx envelope,
	// i.e. the message signed by the user
	if len(v.PayloadSigs) > 0 {
		// Go straight to envelope payload if there are no payload sigs
		return rlpEncode(toEncode)

	} else {
		// Encode Transaction Envelope:
		// If payload sigs are present, only encode the payload message/sig, not the envelope
		// - create new array to rlpEncode using transaction Payload and payload sigs
		var envelopePayloadToEncode []interface{}
		envelopePayloadToEncode = append(envelopePayloadToEncode, toEncode)
		envelopePayloadToEncode = append(envelopePayloadToEncode, v.PayloadSigs)
		envelopePayload := rlpEncode(envelopePayloadToEncode)
		return envelopePayload
	}
}

// Non-custodial wallets will only contain one signer, so payloadSigs
// will be empty, and only the envelope will be signed.
// For Custodial wallets (Blocto/Dapper), the user signs the tx payload
// and envelope is signed by custodian.
//
// This function returns only the signature generated by the user
func GetUserCompositeSignatureFromVoucher(v *Voucher) *[]CompositeSignature {
	var compositeSig CompositeSignature
	if len(v.PayloadSigs) > 0 {
		compositeSig = CompositeSignature{
			Addr:      v.PayloadSigs[0].Address,
			Key_id:    v.PayloadSigs[0].KeyId,
			Signature: v.PayloadSigs[0].Sig,
		}
	} else {
		compositeSig = CompositeSignature{
			Addr:      v.EnvelopeSigs[0].Address,
			Key_id:    v.EnvelopeSigs[0].KeyId,
			Signature: v.EnvelopeSigs[0].Sig,
		}
	}

	return &[]CompositeSignature{compositeSig}
}
